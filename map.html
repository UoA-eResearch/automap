<!DOCTYPE html>
<html>
  <head>
    <title>Centre for eResearch - Automated seaFET map maker</title>
    <link rel="stylesheet" href="https://openlayers.org/en/v4.0.1/css/ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
    <script src="https://openlayers.org/en/v4.0.1/build/ol.js"></script>
    <script src="https://code.jquery.com/jquery-1.8.2.js"></script>
    <script src="https://evanplaice.github.io/jquery-csv/src/jquery.csv.js"></script>
    <script src="//cdn.rawgit.com/walkermatt/ol3-layerswitcher/master/src/ol3-layerswitcher.js" type="text/javascript"></script>
    <link rel="stylesheet" href="//cdn.rawgit.com/walkermatt/ol3-layerswitcher/master/src/ol3-layerswitcher.css" type="text/css">
    <style>
      html, body, .map {
        margin: 0;
        height: 100%;
        width: 100%;
        background-color: #a3ccff;
      }
      #info {
        position: absolute;
        right: 0;
        bottom: 0;
        padding: 5px;
        background-color: white;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map"></div>
    <div id="info">&nbsp;</div>
    <script>
      var style = {
        'Point': new ol.style.Style({
          image: new ol.style.Circle({
            fill: new ol.style.Fill({
              color: 'rgba(255,255,0,0.4)'
            }),
            radius: 5,
            stroke: new ol.style.Stroke({
              color: '#ff0',
              width: 1
            })
          })
        }),
        'LineString': new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: '#f00',
            width: 3
          })
        }),
        'MultiLineString': new ol.style.Style({
          stroke: new ol.style.Stroke({
            color: '#0f0',
            width: 3
          })
        })
      };

      var mid = window.location.pathname.substring(window.location.pathname.indexOf("/map/") + 5)
      var gpx = new ol.source.Vector({
        url: '../datasets/' + mid + '/tracks.gpx',
        format: new ol.format.GPX()
      });
      var vector = new ol.layer.Vector({
        title: 'GPX data',
        source: gpx,
        style: function(feature) {
          return style[feature.getGeometry().getType()];
        }
      });

      function binary_search(haystack, needle) {
        if (haystack.length == 1) return haystack[0]
        var mid = Math.round(haystack.length / 2);
        if (needle < haystack[mid]) {
          return binary_search(haystack.slice(0, mid), needle);
        } else {
          return binary_search(haystack.slice(mid), needle);
        }
      }

      gpx.on('change', function(e) {
        if (gpx.getState() == 'ready') {
          map.getView().fit(gpx.getExtent(), map.getSize());
          var features = gpx.getFeatures();
          var timestampedLatLngs = {}
          var timestamps = []
          for (var i in features) {
            var feature = features[i];
            if (feature.getGeometry().getLayout() == 'XYZM') {
              var coords = feature.getGeometry().getCoordinates();
              for (var i in coords) {
                var segment = coords[i];
                for (var j in segment) {
                  var xyzm = segment[j];
                  var date = xyzm[3];
                  timestamps.push(date);
                  timestampedLatLngs[date] = xyzm;
                }
              }
            }
          }
          console.log(timestampedLatLngs);
          timestamps.sort();
          console.log(timestamps.length + " timestamped gpx waypoints found");
          $.get('../datasets/' + mid + '/seafet.csv', function(data) {
            var arrays = $.csv.toArrays(data);
            var seafet = {};
            var imperfectMatches = 0;
            var internal_ph_data = new ol.source.Vector();
            var external_ph_data = new ol.source.Vector();
            var temp_data = new ol.source.Vector();
            for (var i = 8; i < arrays.length; i++) {
              var e = arrays[i];
              var date = e[1];
              var year = date.slice(0,4);
              var day_of_year = parseInt(date.slice(4));
              var decimal_hours = parseFloat(e[2]);
              var internal_ph = parseFloat(e[3]);
              var external_ph = parseFloat(e[4]);
              var temp = parseFloat(e[5]);
              var date = new Date(year);
              date.setDate(day_of_year);
              date.setSeconds(decimal_hours * 60 * 60);
              var ts = date.getTime() / 1000;
              var matchingLatLng = null;
              if (timestampedLatLngs[ts]) {
                matchingLatLng = timestampedLatLngs[ts];
              } else {
                imperfectMatches++;
                var found = binary_search(timestamps, ts)
                var diff = Math.abs(found - ts);
                var index = timestamps.indexOf(found);
                var neighbours = timestamps.slice(index - 2, index + 2);
                for (var j in neighbours) {
                  var neighbour = neighbours[j];
                  var d = Math.abs(neighbour - ts);
                  if (d < diff) {
                    found = neighbour;
                    diff = d;
                  }
                }
                if (diff < 10) {
                  matchingLatLng = timestampedLatLngs[found];
                }
              }
              if (!matchingLatLng) continue;
              matchingLatLng = new ol.geom.Point(matchingLatLng);
              var internal_ph_pt = new ol.Feature({
                  geometry: matchingLatLng,
                  weight: internal_ph
              });
              var external_ph_pt = new ol.Feature({
                  geometry: matchingLatLng,
                  weight: external_ph
              });
              var temp_pt = new ol.Feature({
                  geometry: matchingLatLng,
                  weight: temp
              });
              internal_ph_data.addFeature(internal_ph_pt);
              external_ph_data.addFeature(external_ph_pt);
              temp_data.addFeature(temp_pt);
            }
            console.log(imperfectMatches + " imperfectMatches in the seafet dataset out of " + (arrays.length - 8));
            console.log(internal_ph_data.getFeatures().length + " heatmap points");

            var internal_ph_heatmap = new ol.layer.Heatmap({
                title: "Internal pH",
                source: internal_ph_data,
                radius: 2,
                visible: false
            });
            var external_ph_heatmap = new ol.layer.Heatmap({
                title: "External pH",
                source: external_ph_data,
                radius: 2,
                visible: false
            });
            var temp_heatmap = new ol.layer.Heatmap({
                title: "Temperature",
                source: temp_data,
                radius: 2,
                visible: true
            });

            map.addLayer(internal_ph_heatmap);
            map.addLayer(external_ph_heatmap);
            map.addLayer(temp_heatmap);
          });
        }
      });

      var map = new ol.Map({
        controls: ol.control.defaults().extend([
          new ol.control.ScaleLine(),
          new ol.control.ZoomSlider(),
          new ol.control.LayerSwitcher()
        ]),
        layers: [
          new ol.layer.Tile({
            title: 'OSM',
            type: 'base',
            source: new ol.source.OSM()
          }),
          vector
        ],
        target: document.getElementById('map'),
        view: new ol.View({
          center: ol.proj.fromLonLat([174.766462, -36.891249]),
          zoom: 12
        })
      });

      var displayFeatureInfo = function(pixel) {
        return;
        var features = [];
        map.forEachFeatureAtPixel(pixel, function(feature) {
          features.push(feature);
        });
        if (features.length > 0) {
          console.log(features);
          var info = [];
          var i, ii;
          for (i = 0, ii = features.length; i < ii; ++i) {
            info.push(features[i].get('desc') || features[i].get('name'));
          }
          document.getElementById('info').innerHTML = info.join(', ') || '(unknown)';
          map.getTarget().style.cursor = 'pointer';
        } else {
          document.getElementById('info').innerHTML = '&nbsp;';
          map.getTarget().style.cursor = '';
        }
      };

      map.on('pointermove', function(evt) {
        if (evt.dragging) {
          return;
        }
        var pixel = map.getEventPixel(evt.originalEvent);
        displayFeatureInfo(pixel);
      });

      map.on('click', function(evt) {
        displayFeatureInfo(evt.pixel);
      });
    </script>
  </body>
</html> 
